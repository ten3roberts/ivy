use std::any;

use anymap::AnyMap;
use atomic_refcell::{AtomicRef, AtomicRefCell, AtomicRefMut};
use owning_ref::OwningRef;
use parking_lot::{RwLock, RwLockReadGuard};

use crate::{Error, Handle, ResourceCache};

type Cell<T> = AtomicRefCell<ResourceCache<T>>;

/// A ResourceManager abstracts and holds ResourceCaches for many different types. This is to avoid
/// having to individually keep track of all Texture, Sampler, Material and other cache and wrap
/// each in a RefCell or Rc.
pub struct ResourceManager {
    caches: RwLock<AnyMap>,
}

impl ResourceManager {
    /// Creates a new empty resource manager. Caches will be added when requested.
    pub fn new() -> Self {
        Self {
            caches: RwLock::new(AnyMap::new()),
        }
    }

    /// Returns a reference to ResourceCache for type `T`
    pub fn cache<T: 'static>(&self) -> Result<OwningRef<AtomicRef<ResourceCache<T>>>, Error> {
        let guard = self.caches.read();

        if let Ok(cache) = RwLockReadGuard::try_map(guard, |guard| guard.get::<Cell<T>>()) {
            return Ok(OwningRef::new(cache));
        } else {
            // Ok(self.create_cache::<T>()?.borrow())
            todo!()
        }
    }

    /// Returns a mutable reference to ResourceCache for type `T`
    // pub fn cache_mut<T: 'static>(&self) -> Result<AtomicRefMut<ResourceCache<T>>, Error> {
    //     let guard = self.caches.read();

    //     if let Some(cache) = guard.get::<Cell<T>>().map(|val| val.borrow_mut()) {
    //         return Ok(cache);
    //     } else {
    //         println!("Inserting new cache");
    //         Ok(self.create_cache::<T>()?.borrow_mut())
    //     }
    // }

    /// Returns a reference to the resource pointed to by Handle<T>. Equivalent to using `cache()` and then `get()`. If dereferencing many handles, prefer gettting the cache first and the using it directly.
    // pub fn get<T: 'static>(&self, handle: Handle<T>) -> Result<AtomicRef<T>, Error> {
    //     let cache = self.cache::<T>()?;

    //     AtomicRef::filter_map(cache, |cache| cache.get(handle).ok())
    //         .ok_or_else(|| Error::InvalidHandle(any::type_name::<T>()))
    // }

    /// Returns a mutable reference to the resource pointed to by Handle<T>. Equivalent to using `cache()` and then `get()`. If dereferencing many handles, prefer gettting the cache first and the using it directly.
    // pub fn get_mut<T: 'static>(&self, handle: Handle<T>) -> Result<AtomicRefMut<T>, Error> {
    //     let cache = self.cache_mut::<T>()?;

    //     AtomicRefMut::filter_map(cache, |cache| cache.get_mut(handle).ok())
    //         .ok_or_else(|| Error::InvalidHandle(any::type_name::<T>()))
    // }

    /// Inserts a resource into the correct cache and returns a handle to acces the resource.
    /// Fails if the cache does not exists.
    // pub fn insert<T: 'static>(&self, resource: T) -> Result<Handle<T>, Error> {
    //     let mut cache = self.cache_mut::<T>()?;

    //     Ok(cache.insert(resource))
    // }

    /// Creates a resource cache for `T`. Does nothing if cache already exists.
    pub fn create_cache<T: 'static>(&mut self) -> Result<&AtomicRefCell<ResourceCache<T>>, Error> {
        let guard = self.caches.write();
        let val = guard
            .entry::<Cell<T>>()
            .or_insert_with(|| AtomicRefCell::new(ResourceCache::<T>::new()));

        Ok(&*val)
    }
}

impl Default for ResourceManager {
    fn default() -> Self {
        Self::new()
    }
}
